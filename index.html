<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Pump Readings (MVP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:20px; }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:12px; }
    button { padding:8px 12px; cursor:pointer; }
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ddd; padding:8px; }
    th { background:#f7f7f7; text-align:left; }
    .pill { padding:2px 8px; border-radius:12px; display:inline-block; }
    .green { background:#e6f7ec; color:#156d2f; }
    .red   { background:#fde8e8; color:#9b1c1c; }
    .muted { color:#666; }
    .panel { border:1px solid #eee; border-radius:10px; padding:12px; margin-bottom:16px; box-shadow:0 1px 2px rgba(0,0,0,0.04); }
    .kv { display:grid; grid-template-columns: 160px 1fr; gap:6px 10px; align-items:center; }
    .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; }
    .small { font-size:12px; }
    #events { white-space:pre-wrap; max-height:160px; overflow:auto; border:1px solid #eee; border-radius:8px; padding:8px; background:#fafafa; }
    #schema { word-break: break-all; }
  </style>
</head>
<body>
  <!-- Auth -->
  <div id="auth" style="margin-bottom:16px; display:none;">
    <h2>Sign in</h2>
    <div class="row">
      <input id="email" type="email" placeholder="Email" />
      <input id="password" type="password" placeholder="Password" />
      <button id="signin">Sign in</button>
    </div>
    <div id="authMsg" style="color:#b00;"></div>
  </div>

  <!-- App -->
  <div id="app" style="display:none;">
    <h1>Pump Readings (MVP)</h1>

    <div class="row">
      <label>Time range:</label>
      <select id="range">
        <option value="6">Last 6 hours</option>
        <option value="24" selected>Last 24 hours</option>
        <option value="168">Last 7 days</option>
      </select>
      <button id="refresh">Refresh</button>
      <div id="status" class="muted"></div>
      <button id="signout" title="Sign out of this browser">Sign out</button>
    </div>

    <!-- Firmware panel -->
    <div class="panel">
      <h3 style="margin-top:0;">Firmware</h3>
      <div class="kv">
        <div class="muted">Current device FW</div>
        <div><span id="fwCurrent" class="mono">—</span></div>

        <div class="muted">Manifest FW</div>
        <div><span id="fwManifest" class="mono">—</span></div>

        <div class="muted">Update available</div>
        <div><span id="fwUpdateFlag" class="pill">—</span></div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button id="fwCheckBtn" title="Fetch manifest.json and compare">Check (compare)</button>
        <button id="fwForceBtn" title="Copies a mosquitto command that makes the device check right now">Force device to check now</button>
        <span id="fwMsg" class="muted small"></span>
      </div>
      <div id="fwCmdWrap" class="small mono" style="display:none; margin-top:8px;">
        <div class="muted">Copied to clipboard:</div>
        <div id="fwCmdText"></div>
      </div>
    </div>

    <!-- Snapshots -->
    <div class="row">
      <div>Latest: <span id="latest" class="pill"></span></div>
      <div>Total rows: <strong id="count">0</strong></div>
      <div>Signal: <span id="signal" class="pill"></span></div>
      <div>Last connected: <span id="lastconn">—</span></div>
      <div>Last seen: <span id="lastseen">—</span></div>
      <div>Wi-Fi: <span id="rssiNow">—</span></div>
      <div>Latest Temp A: <span id="tempALatest">—</span></div>
      <div>Latest Temp B: <span id="tempBLatest">—</span></div>
    </div>

    <!-- Charts -->
    <canvas id="chartA" height="140"></canvas>
    <canvas id="chartB" height="140" style="margin-top:14px;"></canvas>

    <!-- Table -->
    <table style="margin-top:16px;">
      <thead>
        <tr>
          <th>Time (UTC)</th>
          <th>Device</th>
          <th>Status</th>
          <th>Temp A °C</th>
          <th>Temp B °C</th>
          <th>RSSI</th>
          <th>FW</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>

    <!-- Events & schema -->
    <div class="panel" style="margin-top:16px;">
      <h3 style="margin-top:0;">Events</h3>
      <div id="events" class="mono small"></div>
      <div id="schema" class="mono small muted" style="margin-top:6px;"></div>
    </div>
  </div>

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Supabase
    const SUPABASE_URL = "https://ojomcciunusemwszdnrl.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9qb21jY2l1bnVzZW13c3pkbnJsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ3MTUyODYsImV4cCI6MjA3MDI5MTI4Nn0.U7gKI4QOklKkSq_Jbfxm6hQBrvS4JipV7z6KtIl1kz8";
    const MANIFEST_URL = "https://ojomcciunusemwszdnrl.supabase.co/storage/v1/object/public/ota/manifest.json";
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // MQTT helpers (for copyable commands)
    const MQTT = {
      host: "3614c4f5a4b94a56a45e17893c67c2d7.s1.eu.hivemq.cloud",
      port: 8883,
      user: "aug25",
      pass: "f71pSt1cK",
      cafile: "C:\\certs\\cacert.pem",
      devId: "pump-1",
      topicCmd: (id) => `pump/uv/cmd/${id}`
    };

    // UI refs
    const rangeSel = document.getElementById('range');
    const rowsEl = document.getElementById('rows');
    const latestEl = document.getElementById('latest');
    const countEl = document.getElementById('count');
    const signalEl = document.getElementById('signal');
    const lastConnEl = document.getElementById('lastconn');
    const lastSeenEl = document.getElementById('lastseen');
    const rssiNowEl = document.getElementById('rssiNow');
    const tempALatestEl = document.getElementById('tempALatest');
    const tempBLatestEl = document.getElementById('tempBLatest');
    const statusEl = document.getElementById('status');
    const authEl = document.getElementById('auth');
    const appEl = document.getElementById('app');
    const emailEl = document.getElementById('email');
    const passwordEl = document.getElementById('password');
    const signinBtn = document.getElementById('signin');
    const authMsgEl = document.getElementById('authMsg');
    const signoutBtn = document.getElementById('signout');

    // Firmware panel
    const fwCurrentEl = document.getElementById('fwCurrent');
    const fwManifestEl = document.getElementById('fwManifest');
    const fwUpdateFlagEl = document.getElementById('fwUpdateFlag');
    const fwCheckBtn = document.getElementById('fwCheckBtn');
    const fwForceBtn = document.getElementById('fwForceBtn');
    const fwMsgEl = document.getElementById('fwMsg');
    const fwCmdWrap = document.getElementById('fwCmdWrap');
    const fwCmdText = document.getElementById('fwCmdText');

    // Events & schema
    const eventsEl = document.getElementById('events');
    const schemaEl = document.getElementById('schema');
    function log(msg){ const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`; eventsEl.textContent = line + eventsEl.textContent; }

    // ------- dynamic column mapping (learn from latest row) -------
    let COL = null; // { tsKey, fwKey, aKey, bKey, rssiKey, uvKey, devKey }
    function detectColumns(row){
      if (!row) return null;
      const keys = Object.keys(row);
      const L = keys.map(k=>k.toLowerCase());
      const pickFirst = (...cands)=> {
        for (const c of cands){
          const i = L.indexOf(c); if (i>=0) return keys[i];
        }
        return null;
      };
      const findIncl = (inclFn)=> {
        for (let i=0;i<keys.length;i++){ if (inclFn(keys[i].toLowerCase())) return keys[i]; }
        return null;
      };

      // time
      let tsKey = pickFirst('ts','created_at','time','timestamp');
      if (!tsKey) tsKey = findIncl(k => k.includes('time') || k.includes('date'));

      // firmware
      let fwKey = pickFirst('fw','firmware','version','fw_version');

      // status / device / rssi
      let uvKey   = pickFirst('uv_status','status');
      let devKey  = pickFirst('device_id','device');
      let rssiKey = pickFirst('rssi','wifi_rssi');

      // temps: prefer *_pump_a_* or *_a_*, and *_pump_b_* or *_b_*. Prefer *_c.
      const tempKeys = keys.filter(k => k.toLowerCase().includes('temp'));
      function chooseTemp(which){ // which = 'a' | 'b'
        const pri = tempKeys.filter(k=>{
          const s=k.toLowerCase();
          return (s.includes(`pump_${which}`) || s.endsWith(`_${which}`) || s.includes(`_${which}_`));
        }).sort((x,y)=> (y.toLowerCase().includes('_c')?1:0) - (x.toLowerCase().includes('_c')?1:0));
        if (pri.length) return pri[0];
        // otherwise: any temp that ends with _c
        const cOnly = tempKeys.filter(k=>k.toLowerCase().endsWith('_c'));
        if (cOnly.length) return cOnly[0];
        return tempKeys[0] || null;
      }
      let aKey = chooseTemp('a');
      let bKey = chooseTemp('b');
      // avoid A==B
      if (aKey && bKey && aKey===bKey){
        const others = tempKeys.filter(k=>k!==aKey);
        bKey = others[0] || null;
      }

      return { tsKey, fwKey, aKey, bKey, rssiKey, uvKey, devKey, keys };
    }

    // helpers using current COL + per-row fallback
    function val(r, k){ return (k && r[k] != null) ? r[k] : null; }
    function tsOf(r){ return val(r, COL?.tsKey) ?? r.ts ?? r.created_at ?? r.time; }
    function fwOf(r){ return val(r, COL?.fwKey) ?? r.fw ?? r.firmware ?? r.version; }
    function rssiOf(r){ return val(r, COL?.rssiKey) ?? r.rssi ?? r.wifi_rssi; }
    function uvOf(r){ return val(r, COL?.uvKey) ?? r.uv_status ?? r.status; }
    function devOf(r){ return val(r, COL?.devKey) ?? r.device_id ?? r.device; }
    function tempAOf(r){
      let v = val(r, COL?.aKey);
      if (v==null) v = r.temp_pump_a_c ?? r.temp_a_c ?? r.temp_a ?? r.temp_c ?? r.temp;
      return v;
    }
    function tempBOf(r){
      let v = val(r, COL?.bKey);
      if (v==null) v = r.temp_pump_b_c ?? r.temp_b_c ?? r.temp_b;
      return v;
    }

    // Charts
    let chartA, chartB;
    function renderCharts(rows){
      const ordered = rows.slice().reverse();
      const labels = ordered.map(r => new Date(tsOf(r)).toLocaleTimeString());
      const valsA = ordered.map(r => { const v=tempAOf(r); return v==null?null:Number(v); });
      const valsB = ordered.map(r => { const v=tempBOf(r); return v==null?null:Number(v); });

      const ctxA = document.getElementById('chartA').getContext('2d');
      const ctxB = document.getElementById('chartB').getContext('2d');
      const dsA = [{ data: valsA, spanGaps:true, pointRadius:0, borderWidth:2, label:'Temp A (°C)' }];
      const dsB = [{ data: valsB, spanGaps:true, pointRadius:0, borderWidth:2, label:'Temp B (°C)' }];
      const opts = { animation:false, plugins:{legend:{display:true}}, scales:{ y:{ title:{display:true,text:'°C'} } } };

      if (!chartA) chartA = new Chart(ctxA, { type:'line', data:{ labels, datasets:dsA }, options:opts });
      else { chartA.data.labels = labels; chartA.data.datasets[0].data = valsA; chartA.update('none'); }

      if (!chartB) chartB = new Chart(ctxB, { type:'line', data:{ labels, datasets:dsB }, options:opts });
      else { chartB.data.labels = labels; chartB.data.datasets[0].data = valsB; chartB.update('none'); }
    }

    // Data fetch
    async function queryPumpReadings(hours){
      const fromIso = new Date(Date.now() - hours*3600*1000).toISOString();
      // 1) preferred: time-bounded
      let { data, error } = await sb
        .from('pump_readings')
        .select('*')
        .gte('ts', fromIso)
        .order('ts', { ascending:false })
        .limit(500);
      if (error){ log('Query error: ' + error.message); return { data:[], error }; }
      // 2) fallback: last 200 rows if empty
      if (!data || data.length===0){
        log('No rows in range; falling back to last 200…');
        const r = await sb.from('pump_readings').select('*').order('ts',{ascending:false}).limit(200);
        if (r.error){ log('Fallback query error: ' + r.error.message); return { data:[], error:r.error }; }
        data = r.data || [];
      }
      return { data, error:null };
    }

    function renderRows(data){
      rowsEl.innerHTML = '';
      for (const r of data){
        const tA = tempAOf(r), tB = tempBOf(r);
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${new Date(tsOf(r)).toISOString()}</td>
          <td>${devOf(r) ?? ''}</td>
          <td><span class="pill ${(uvOf(r)==='GREEN') ? 'green' : 'red'}">${uvOf(r) ?? ''}</span></td>
          <td>${tA==null?'':Number(tA).toFixed(2)}</td>
          <td>${tB==null?'':Number(tB).toFixed(2)}</td>
          <td>${rssiOf(r) ?? ''}</td>
          <td class="mono">${fwOf(r) ?? ''}</td>
        `;
        rowsEl.appendChild(tr);
      }
    }

    async function load(){
      const { data: { session } } = await sb.auth.getSession();
      if (!session){ log('No session; waiting for sign-in.'); return; }

      const hours = parseInt(rangeSel.value,10);
      statusEl.textContent = 'Loading…';
      log('Load start (range=' + hours + 'h)…');

      const { data, error } = await queryPumpReadings(hours);
      if (error){ statusEl.textContent = 'Error: ' + error.message; return; }

      countEl.textContent = data.length;
      if (data.length){
        // Learn mapping from latest row
        COL = detectColumns(data[0]);
        schemaEl.textContent = COL
          ? `Detected → ts:${COL.tsKey || '—'}, fw:${COL.fwKey || '—'}, A:${COL.aKey || '—'}, B:${COL.bKey || '—'}, rssi:${COL.rssiKey || '—'}, status:${COL.uvKey || '—'}, device:${COL.devKey || '—'} | Keys: ${COL.keys.join(', ')}`
          : 'Could not detect columns (no row?)';

        const latest = data[0];
        latestEl.textContent = uvOf(latest) || '—';
        latestEl.className = 'pill ' + ((uvOf(latest) === 'GREEN') ? 'green' : 'red');

        const tA = tempAOf(latest), tB = tempBOf(latest);
        tempALatestEl.textContent = (tA==null)?'—':(+tA).toFixed(2) + ' °C';
        tempBLatestEl.textContent = (tB==null)?'—':(+tB).toFixed(2) + ' °C';

        const fwCur = fwOf(latest);
        fwCurrentEl.textContent = fwCur || '—';

        // device_status (best-effort)
        try{
          const did = devOf(latest);
          const { data: ds, error: dserr } = await sb
            .from('device_status')
            .select('last_seen_ts, last_online_ts, online')
            .eq('device_id', did)
            .single();
          if (!dserr && ds){
            lastConnEl.textContent = ds.last_online_ts ? new Date(ds.last_online_ts).toLocaleString() : (ds.online?'now':'—');
            lastSeenEl.textContent = ds.last_seen_ts ? new Date(ds.last_seen_ts).toLocaleString() : (ds.online?'now':'—');
            const fresh = data.filter(r => rssiOf(r) != null && (Date.now()-new Date(tsOf(r)).getTime()) <= 120000).slice(0,5);
            if (fresh.length){ const avg = fresh.reduce((s,r)=>s+Number(rssiOf(r)), 0)/fresh.length; rssiNowEl.textContent = `${avg.toFixed(0)} dBm (${rssiLabel(avg)})`; } else { rssiNowEl.textContent = 'No signal'; }
          } else {
            lastConnEl.textContent = '—'; lastSeenEl.textContent = '—';
          }
        } catch(_){ /* ignore */ }

      } else {
        latestEl.textContent = '—'; latestEl.className = 'pill';
        fwCurrentEl.textContent = '—';
        rssiNowEl.textContent = '—';
        schemaEl.textContent = 'No rows found.';
      }

      renderRows(data);
      renderCharts(data);

      // Staleness badge
      if (data.length){
        const ageMs = Date.now() - new Date(tsOf(data[0])).getTime();
        const ageMin = Math.floor(ageMs/60000);
        const fresh = ageMin <= 10;
        signalEl.textContent = fresh ? 'OK' : `STALE: ${ageMin}m`;
        signalEl.className = 'pill ' + (fresh ? 'green' : 'red');
      } else {
        signalEl.textContent = 'NO DATA';
        signalEl.className = 'pill red';
      }

      statusEl.textContent = 'Last updated: ' + new Date().toLocaleTimeString();
      log('Load done: rows=' + data.length);
    }

    // Manifest compare (with direct DB fallback for current FW)
    async function fetchManifest(){
      const url = MANIFEST_URL + '?cb=' + Date.now();
      const res = await fetch(url, { cache:'no-store' });
      if (!res.ok) throw new Error('manifest fetch ' + res.status);
      return res.json();
    }

    async function ensureFwCurrent(){
      const cur = (fwCurrentEl.textContent || '').trim();
      if (cur && cur !== '—') return cur;
      // fast 1-row fetch to learn FW directly
      const r = await sb.from('pump_readings').select('*').order('ts',{ascending:false}).limit(1);
      if (r.data && r.data.length){
        if (!COL) COL = detectColumns(r.data[0]);
        const fwCur = fwOf(r.data[0]);
        if (fwCur){ fwCurrentEl.textContent = fwCur; return fwCur; }
      }
      return null;
    }

    async function refreshFirmwareCompare(){
      fwMsgEl.textContent = 'Fetching manifest…';
      fwCmdWrap.style.display = 'none';
      try{
        const manifest = await fetchManifest();
        const mver = manifest.version || '—';
        fwManifestEl.textContent = mver;

        let cur = (fwCurrentEl.textContent || '').trim();
        if (!cur || cur==='—'){
          cur = await ensureFwCurrent();
        }
        if (!cur || cur==='—' || !mver || mver==='—'){
          fwUpdateFlagEl.textContent = '—';
          fwUpdateFlagEl.className = 'pill';
          fwMsgEl.textContent = '';
          log('Manifest fetched, current FW unknown yet.');
          return;
        }
        const newer = (function cmp(a,b){ const pa=String(a).split('.').map(n=>parseInt(n,10)); const pb=String(b).split('.').map(n=>parseInt(n,10)); for(let i=0;i<3;i++){const x=pa[i]||0,y=pb[i]||0; if(x!==y) return x<y; } return false; })(cur, mver);

        fwUpdateFlagEl.textContent = newer ? 'YES' : 'No';
        fwUpdateFlagEl.className = 'pill ' + (newer ? 'red' : 'green');
        fwMsgEl.textContent = newer ? 'New firmware available in manifest.' : 'Device is up to date.';
        log(`Manifest compare: current=${cur}, manifest=${mver}, update=${newer?'YES':'No'}`);
      }catch(e){
        fwManifestEl.textContent = '—';
        fwUpdateFlagEl.textContent = '—';
        fwUpdateFlagEl.className = 'pill';
        fwMsgEl.textContent = 'Manifest fetch failed.';
        log('Manifest fetch failed: ' + e.message);
      }
    }

    // Copyable force-check command
    function buildForceCheckCommand(){
      const topic = MQTT.topicCmd(MQTT.devId);
      // all escaping is CMD-safe and already tested
      return `"C:\\Program Files\\mosquitto\\mosquitto_pub.exe" -h ${MQTT.host} -p ${MQTT.port} -V mqttv311 --cafile "${MQTT.cafile}" -u ${MQTT.user} -P ${MQTT.pass} -t "${topic}" -m "{\\"cmd\\":\\"check_update\\"}"`;
    }
    async function copyForceCheck(){
      const cmd = buildForceCheckCommand();
      try{ await navigator.clipboard.writeText(cmd); }catch(_){}
      fwCmdText.textContent = cmd;
      fwCmdWrap.style.display = 'block';
      fwMsgEl.textContent = 'Command copied. Paste into Command Prompt to make the device check now.';
      log('Copied force-check command to clipboard.');
    }

    // Auth/UI wiring
    async function refreshAuthUI(){
      const { data: { session } } = await sb.auth.getSession();
      const authed = !!session;
      authEl.style.display = authed ? 'none' : 'block';
      appEl.style.display  = authed ? 'block' : 'none';
      if (authed){
        await load();
        await refreshFirmwareCompare();
      }
    }
    document.getElementById('refresh').addEventListener('click', async () => { await load(); await refreshFirmwareCompare(); });
    rangeSel.addEventListener('change', async () => { await load(); await refreshFirmwareCompare(); });
    fwCheckBtn.addEventListener('click', refreshFirmwareCompare);
    fwForceBtn.addEventListener('click', copyForceCheck);

    document.getElementById('signin').addEventListener('click', async () => {
      authMsgEl.textContent = '';
      const { error } = await sb.auth.signInWithPassword({ email: emailEl.value.trim(), password: passwordEl.value });
      if (error){ authMsgEl.textContent = error.message; return; }
      await refreshAuthUI();
    });
    signoutBtn.addEventListener('click', async () => { await sb.auth.signOut(); await refreshAuthUI(); });

    // Start + auto-refresh
    refreshAuthUI();
    setInterval(async () => { await load(); await refreshFirmwareCompare(); }, 10000);

    // RSSI helper
    function rssiLabel(dbm){ if (dbm>=-60) return 'Excellent'; if (dbm>=-67) return 'Very good'; if (dbm>=-75) return 'Good'; if (dbm>=-82) return 'Fair'; if (dbm>=-90) return 'Poor'; return 'Very poor'; }
  </script>
</body>
</html>
